"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDeviceInfoAsync = getDeviceInfoAsync;

function _lodash() {
  const data = _interopRequireDefault(require("lodash"));

  _lodash = function () {
    return data;
  };

  return data;
}

function _child_process() {
  const data = _interopRequireDefault(require("child_process"));

  _child_process = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _jsonFile() {
  const data = _interopRequireDefault(require("@expo/json-file"));

  _jsonFile = function () {
    return data;
  };

  return data;
}

function _os() {
  const data = _interopRequireDefault(require("os"));

  _os = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _rimraf() {
  const data = _interopRequireDefault(require("rimraf"));

  _rimraf = function () {
    return data;
  };

  return data;
}

function _spawnAsync() {
  const data = _interopRequireDefault(require("@expo/spawn-async"));

  _spawnAsync = function () {
    return data;
  };

  return data;
}

function _tar() {
  const data = _interopRequireDefault(require("tar"));

  _tar = function () {
    return data;
  };

  return data;
}

function _ip() {
  const data = _interopRequireDefault(require("./ip"));

  _ip = function () {
    return data;
  };

  return data;
}

function _Api() {
  const data = _interopRequireDefault(require("./Api"));

  _Api = function () {
    return data;
  };

  return data;
}

function Binaries() {
  const data = _interopRequireWildcard(require("./Binaries"));

  Binaries = function () {
    return data;
  };

  return data;
}

function Env() {
  const data = _interopRequireWildcard(require("./Env"));

  Env = function () {
    return data;
  };

  return data;
}

function _FormData() {
  const data = _interopRequireDefault(require("./tools/FormData"));

  _FormData = function () {
    return data;
  };

  return data;
}

function _User() {
  const data = _interopRequireWildcard(require("./User"));

  _User = function () {
    return data;
  };

  return data;
}

function _UserSettings() {
  const data = _interopRequireDefault(require("./UserSettings"));

  _UserSettings = function () {
    return data;
  };

  return data;
}

function Utils() {
  const data = _interopRequireWildcard(require("./Utils"));

  Utils = function () {
    return data;
  };

  return data;
}

function Watchman() {
  const data = _interopRequireWildcard(require("./Watchman"));

  Watchman = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function _uploadLogsAsync(info) {
  let user = await _User().default.getCurrentUserAsync();
  let username = user ? user.username : _User().ANONYMOUS_USERNAME; // write info to file

  let expoHome = _UserSettings().default.dotExpoHomeDirectory();

  let infoJsonFile = new (_jsonFile().default)(_path().default.join(expoHome, 'debug-info.json'));
  await infoJsonFile.writeAsync(info); // copy files to tempDir

  let tempDir = _path().default.join(Env().home(), `${username}-diagnostics`);

  let archivePath = _path().default.join(expoHome, 'diagnostics.tar.gz');

  await Utils().ncpAsync(expoHome, tempDir, {
    filter: filename => {
      if (filename.includes('diagnostics') || filename.includes('starter-app-cache') || filename.includes('android-apk-cache') || filename.includes('ios-simulator-app-cache') || filename.includes('state.json~')) {
        return false;
      } else {
        return true;
      }
    }
  }); // remove access token

  try {
    let settingsJsonFile = new (_jsonFile().default)(_path().default.join(tempDir, _UserSettings().default.SETTINGS_FILE_NAME));
    let settingsJson = await settingsJsonFile.readAsync();

    for (let key of ['accessToken', 'auth', 'uuid', 'sendTo']) {
      if (settingsJson[key]) {
        settingsJson[key] = 'redacted';
      }
    }

    await settingsJsonFile.writeAsync(settingsJson);
  } catch (e) {
    console.error(e);
  } // compress


  await _tar().default.create({
    file: archivePath,
    gzip: true,
    cwd: Env().home()
  }, [_path().default.relative(Env().home(), tempDir)]);

  _rimraf().default.sync(tempDir); // upload


  let formData = new (_FormData().default)();
  formData.append('archive', _fsExtra().default.createReadStream(archivePath));
  let response = await _Api().default.callMethodAsync('uploadDiagnostics', [{}], 'put', null, {
    formData
  });
  return response.url;
}
/* eslint-disable prefer-template */
// From http://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript


function _formatBytes(bytes) {
  if (bytes >= 1000000000) {
    return (bytes / 1000000000).toFixed(2) + ' GB';
  } else if (bytes >= 1000000) {
    return (bytes / 1000000).toFixed(2) + ' MB';
  } else if (bytes >= 1000) {
    return (bytes / 1000).toFixed(2) + ' KB';
  } else if (bytes > 1) {
    return bytes + ' bytes';
  } else if (bytes === 1) {
    return bytes + '${bytes} byte';
  } else {
    return '0 bytes';
  }
}
/* eslint-enable prefer-template */


async function getDeviceInfoAsync(options = {}) {
  let info = {};
  let whichCommand = process.platform === 'win32' ? 'where' : 'which';

  try {
    let result = await (0, _spawnAsync().default)('node', ['--version']);
    info.nodeVersion = _lodash().default.trim(result.stdout);
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync().default)(whichCommand, ['node']);
    info.nodePath = _lodash().default.trim(result.stdout);
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync().default)('npm', ['--version']);
    info.npmVersion = _lodash().default.trim(result.stdout);
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync().default)(whichCommand, ['npm']);
    info.npmPath = _lodash().default.trim(result.stdout);
  } catch (e) {}

  try {
    info.watchmanVersion = await Watchman().unblockAndGetVersionAsync();
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync().default)(whichCommand, ['watchman']);
    info.watchmanPath = _lodash().default.trim(result.stdout);
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync().default)('adb', ['version']);
    info.adbVersion = _lodash().default.trim(result.stdout);
  } catch (e) {}

  try {
    let result = await (0, _spawnAsync().default)(whichCommand, ['adb']);
    info.adbPath = _lodash().default.trim(result.stdout);
  } catch (e) {}

  info.path = process.env.PATH;
  info.shell = process.env.SHELL;
  info.home = _os().default.homedir();
  info.nvmPath = process.env.NVM_PATH;
  info.lang = process.env.LANG;
  info.dirname = __dirname;
  info.memoryFree = _formatBytes(_os().default.freemem());
  info.memoryTotal = _formatBytes(_os().default.totalmem());
  info.ip = _ip().default.address();
  info.hostname = _os().default.hostname(); // TODO: fix these commands on linux

  if (process.platform === 'darwin') {
    // || process.platform === 'linux') {
    try {
      info.xdeProcesses = _lodash().default.trim(_child_process().default.execSync('pgrep XDE | xargs ps -p').toString());
    } catch (e) {}

    try {
      info.numXdeProcesses = _lodash().default.trim(_child_process().default.execSync('pgrep XDE | wc -l').toString());
    } catch (e) {}

    try {
      info.watchmanProcesses = _lodash().default.trim(_child_process().default.execSync('pgrep watchman | xargs ps -p').toString());
    } catch (e) {}

    try {
      info.numWatchmanProcesses = _lodash().default.trim(_child_process().default.execSync('pgrep watchman | wc -l').toString());
    } catch (e) {}

    try {
      info.ngrokProcesses = _lodash().default.trim(_child_process().default.execSync('pgrep ngrok | xargs ps -p').toString());
    } catch (e) {}

    try {
      info.numNgrokProcesses = _lodash().default.trim(_child_process().default.execSync('pgrep ngrok | wc -l').toString());
    } catch (e) {}
  }

  if (process.platform === 'darwin') {
    // `xcrun` and `xcodebuild` will pop up a dialog if Xcode isn't installed
    if (Binaries().isXcodeInstalled()) {
      try {
        let result = await (0, _spawnAsync().default)('xcrun', ['--version']);
        info.xcrunVersion = _lodash().default.trim(result.stdout);
      } catch (e) {}

      try {
        let result = await (0, _spawnAsync().default)('xcodebuild', ['-version']);
        info.xcodebuildVersion = _lodash().default.trim(result.stdout);
      } catch (e) {}
    }

    try {
      let result = await (0, _spawnAsync().default)('launchctl', ['limit']);
      info.launchctlLimit = _lodash().default.trim(result.stdout);
    } catch (e) {}
  } // TODO: can probably get rid of these options if we remove Intercom


  if (options.uploadLogs) {
    info.url = await _uploadLogsAsync(info);
  }

  if (options.limitLengthForIntercom) {
    info = _lodash().default.mapValues(info, value => {
      if (value && value.length > 100 && !value.startsWith('http')) {
        return value.substring(0, 100);
      } else {
        return value;
      }
    });
  }

  return info;
}
//# sourceMappingURL=__sourcemaps__/Diagnostics.js.map
