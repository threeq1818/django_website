"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAsync = extractAsync;

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _tar() {
  const data = _interopRequireDefault(require("tar"));

  _tar = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _spawnAsync() {
  const data = _interopRequireDefault(require("@expo/spawn-async"));

  _spawnAsync = function () {
    return data;
  };

  return data;
}

function _uuid() {
  const data = _interopRequireDefault(require("uuid"));

  _uuid = function () {
    return data;
  };

  return data;
}

function Binaries() {
  const data = _interopRequireWildcard(require("./Binaries"));

  Binaries = function () {
    return data;
  };

  return data;
}

function _UserSettings() {
  const data = _interopRequireDefault(require("./UserSettings"));

  _UserSettings = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function _extractWindowsAsync(archive, dir) {
  let dotExpoHomeDirectory = _UserSettings().default.dotExpoHomeDirectory();

  let tmpDir = _path().default.join(dotExpoHomeDirectory, 'tmp', _uuid().default.v4());

  _fsExtra().default.mkdirpSync(tmpDir);

  let binary = _path().default.join(Binaries().getBinariesPath(), '7z1602-extra', '7za');

  try {
    await (0, _spawnAsync().default)(binary, ['x', archive, '-aoa', `-o${tmpDir}`]); // We don't know the resulting filename after this step, so
    // just assume the only file in the directory is our .tar file.
    // This should be fine since we created the directory with a random name.

    let files = _fsExtra().default.readdirSync(tmpDir);

    let outputFile = _path().default.resolve(tmpDir, files[0]);

    await (0, _spawnAsync().default)(binary, ['x', outputFile, '-aoa', `-o${dir}`]);
  } catch (e) {
    console.error(e.message);
    console.error(e.stderr);
    throw e;
  } finally {
    _fsExtra().default.removeSync(tmpDir);
  }
}

async function extractAsync(archive, dir) {
  try {
    if (process.platform === 'win32') {
      await _extractWindowsAsync(archive, dir);
    } else {
      await (0, _spawnAsync().default)('tar', ['-xf', archive, '-C', dir], {
        stdio: 'inherit',
        cwd: __dirname
      });
    }
  } catch (e) {
    // tar node module has previously had problems with big files, and seems to
    // be slower, so only use it as a backup.
    console.error(e.message);
    await _tar().default.extract({
      file: archive,
      cwd: dir
    });
  }
}
//# sourceMappingURL=__sourcemaps__/Extract.js.map
