"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.versionsAsync = versionsAsync;
exports.sdkVersionsAsync = sdkVersionsAsync;
exports.setVersionsAsync = setVersionsAsync;
exports.gteSdkVersion = gteSdkVersion;
exports.lteSdkVersion = lteSdkVersion;
exports.parseSdkVersionFromTag = parseSdkVersionFromTag;
exports.newestSdkVersionAsync = newestSdkVersionAsync;
exports.oldestSupportedMajorVersionAsync = oldestSupportedMajorVersionAsync;
exports.facebookReactNativeVersionsAsync = facebookReactNativeVersionsAsync;
exports.facebookReactNativeVersionToExpoVersionAsync = facebookReactNativeVersionToExpoVersionAsync;
exports.canTurtleBuildSdkVersion = canTurtleBuildSdkVersion;

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _forEach() {
  const data = _interopRequireDefault(require("lodash/forEach"));

  _forEach = function () {
    return data;
  };

  return data;
}

function _pickBy() {
  const data = _interopRequireDefault(require("lodash/pickBy"));

  _pickBy = function () {
    return data;
  };

  return data;
}

function _get() {
  const data = _interopRequireDefault(require("lodash/get"));

  _get = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _ApiV() {
  const data = _interopRequireDefault(require("./ApiV2"));

  _ApiV = function () {
    return data;
  };

  return data;
}

function _FsCache() {
  const data = require("./tools/FsCache");

  _FsCache = function () {
    return data;
  };

  return data;
}

function _XDLError() {
  const data = _interopRequireDefault(require("./XDLError"));

  _XDLError = function () {
    return data;
  };

  return data;
}

function _User() {
  const data = _interopRequireDefault(require("./User"));

  _User = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function versionsAsync() {
  const api = new (_ApiV().default)();
  const versionCache = new (_FsCache().Cacher)(() => api.getAsync('versions/latest'), 'versions.json', 0, _path().default.join(__dirname, '../caches/versions.json'));
  return await versionCache.getAsync();
}

async function sdkVersionsAsync() {
  const {
    sdkVersions
  } = await versionsAsync();
  return sdkVersions;
}

async function setVersionsAsync(value) {
  const user = await _User().default.getCurrentUserAsync();

  const api = _ApiV().default.clientForUser(user);

  const secret = process.env.EXPO_VERSIONS_SECRET;
  if (!secret) throw new Error('Versions.setVersionsAsync: EXPO_VERSIONS_SECRET environment variable is required');
  await api.postAsync('versions/update', {
    value: value,
    secret
  });
}

function gteSdkVersion(expJson, sdkVersion) {
  if (!expJson.sdkVersion) {
    return false;
  }

  if (expJson.sdkVersion === 'UNVERSIONED') {
    return true;
  }

  try {
    return _semver().default.gte(expJson.sdkVersion, sdkVersion);
  } catch (e) {
    throw new (_XDLError().default)('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
  }
}

function lteSdkVersion(expJson, sdkVersion) {
  if (!expJson.sdkVersion) {
    return false;
  }

  if (expJson.sdkVersion === 'UNVERSIONED') {
    return false;
  }

  try {
    return _semver().default.lte(expJson.sdkVersion, sdkVersion);
  } catch (e) {
    throw new (_XDLError().default)('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
  }
}

function parseSdkVersionFromTag(tag) {
  if (tag.startsWith('sdk-')) {
    return tag.substring(4);
  }

  return tag;
}

async function newestSdkVersionAsync() {
  let sdkVersions = await sdkVersionsAsync();
  let result = null;
  let highestMajorVersion = '0.0.0';
  (0, _forEach().default)(sdkVersions, (value, key) => {
    if (_semver().default.major(key) > _semver().default.major(highestMajorVersion)) {
      highestMajorVersion = key;
      result = value;
    }
  });
  return {
    version: highestMajorVersion,
    data: result
  };
}

async function oldestSupportedMajorVersionAsync() {
  const sdkVersions = await sdkVersionsAsync();
  const supportedVersions = (0, _pickBy().default)(sdkVersions, v => !v.isDeprecated);
  let versionNumbers = [];
  (0, _forEach().default)(supportedVersions, (value, key) => {
    versionNumbers.push(_semver().default.major(key));
  });
  return Math.min(...versionNumbers);
}

async function facebookReactNativeVersionsAsync() {
  let sdkVersions = await sdkVersionsAsync();
  let facebookReactNativeVersions = new Set();
  (0, _forEach().default)(sdkVersions, value => {
    if (value.facebookReactNativeVersion) {
      facebookReactNativeVersions.add(value.facebookReactNativeVersion);
    }
  });
  return Array.from(facebookReactNativeVersions);
}

async function facebookReactNativeVersionToExpoVersionAsync(facebookReactNativeVersion) {
  if (!_semver().default.valid(facebookReactNativeVersion)) {
    throw new (_XDLError().default)('INVALID_VERSION', `${facebookReactNativeVersion} is not a valid version. Must be in the form of x.y.z`);
  }

  let sdkVersions = await sdkVersionsAsync();
  let currentSdkVersion = null;
  (0, _forEach().default)(sdkVersions, (value, key) => {
    if (_semver().default.major(value.facebookReactNativeVersion) === _semver().default.major(facebookReactNativeVersion) && _semver().default.minor(value.facebookReactNativeVersion) === _semver().default.minor(facebookReactNativeVersion) && (!currentSdkVersion || _semver().default.gt(key, currentSdkVersion))) {
      currentSdkVersion = key;
    }
  });
  return currentSdkVersion;
}

async function canTurtleBuildSdkVersion(sdkVersion, platform) {
  if (sdkVersion === 'UNVERSIONED') {
    return true;
  }

  if (_semver().default.valid(sdkVersion) == null) {
    throw new (_XDLError().default)('INVALID_VERSION', `"${sdkVersion}" is not a valid version. Must be in the form of x.y.z`);
  }

  const supportedVersions = await getSdkVersionsSupportedByTurtle();
  const supportedVersionsForPlatform = (0, _get().default)(supportedVersions, platform, []);
  return supportedVersionsForPlatform.indexOf(sdkVersion) !== -1;
}

async function getSdkVersionsSupportedByTurtle() {
  const api = new (_ApiV().default)();
  return await api.getAsync('standalone-build/supportedSDKVersions');
}
//# sourceMappingURL=__sourcemaps__/Versions.js.map
