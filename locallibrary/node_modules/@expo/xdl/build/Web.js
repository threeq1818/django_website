"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDebugModeEnabled = isDebugModeEnabled;
exports.isInfoEnabled = isInfoEnabled;
exports.shouldWebpackClearLogs = shouldWebpackClearLogs;
exports.logEnvironmentInfo = logEnvironmentInfo;
exports.invokeWebpackConfigAsync = invokeWebpackConfigAsync;
exports.openProjectAsync = openProjectAsync;
exports.onlySupportsWebAsync = onlySupportsWebAsync;

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _getenv() {
  const data = _interopRequireDefault(require("getenv"));

  _getenv = function () {
    return data;
  };

  return data;
}

function _openBrowser() {
  const data = _interopRequireDefault(require("react-dev-utils/openBrowser"));

  _openBrowser = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _Logger() {
  const data = _interopRequireDefault(require("./Logger"));

  _Logger = function () {
    return data;
  };

  return data;
}

function Doctor() {
  const data = _interopRequireWildcard(require("./project/Doctor"));

  Doctor = function () {
    return data;
  };

  return data;
}

function _ProjectUtils() {
  const data = require("./project/ProjectUtils");

  _ProjectUtils = function () {
    return data;
  };

  return data;
}

function UrlUtils() {
  const data = _interopRequireWildcard(require("./UrlUtils"));

  UrlUtils = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @ts-ignore missing types for Doctor until it gets converted to TypeScript
// When you have errors in the production build that aren't present in the development build you can use `EXPO_WEB_DEBUG=true expo start --no-dev` to debug those errors.
// - Prevent the production build from being minified
// - Include file path info comments in the bundle
function isDebugModeEnabled() {
  return _getenv().default.boolish('EXPO_WEB_DEBUG', false);
}

function isInfoEnabled() {
  return _getenv().default.boolish('EXPO_WEB_INFO', false);
}

function shouldWebpackClearLogs() {
  return !isDebugModeEnabled() && !isInfoEnabled() && !_getenv().default.boolish('EXPO_DEBUG', false);
}

function logEnvironmentInfo(projectRoot, tag, config) {
  if (isDebugModeEnabled() && config.mode === 'production') {
    (0, _ProjectUtils().logWarning)(projectRoot, tag, `Webpack is bundling your project in \`production\` mode with the ${_chalk().default.bold('`EXPO_WEB_DEBUG`')} environment variable enabled. You should toggle it off before building for production.`);
  }
}

function applyEnvironmentVariables(config) {
  // Use EXPO_DEBUG_WEB=true to enable debugging features for cases where the prod build
  // has errors that aren't caught in development mode.
  // Related: https://github.com/expo/expo-cli/issues/614
  if (isDebugModeEnabled() && config.mode === 'production') {
    console.log(_chalk().default.bgYellow.black('Bundling the project in debug mode.'));
    const output = config.output || {};
    const optimization = config.optimization || {}; // Enable line to line mapped mode for all/specified modules.
    // Line to line mapped mode uses a simple SourceMap where each line of the generated source is mapped to the same line of the original source.
    // Itâ€™s a performance optimization. Only use it if your performance need to be better and you are sure that input lines match which generated lines.
    // true enables it for all modules (not recommended)

    output.devtoolLineToLine = true; // Add comments that describe the file import/exports.
    // This will make it easier to debug.

    output.pathinfo = true; // Instead of numeric ids, give modules readable names for better debugging.

    optimization.namedModules = true; // Instead of numeric ids, give chunks readable names for better debugging.

    optimization.namedChunks = true; // Readable ids for better debugging.
    // @ts-ignore Property 'moduleIds' does not exist.

    optimization.moduleIds = 'named'; // if optimization.namedChunks is enabled optimization.chunkIds is set to 'named'.
    // This will manually enable it just to be safe.
    // @ts-ignore Property 'chunkIds' does not exist.

    optimization.chunkIds = 'named';

    if (optimization.splitChunks) {
      optimization.splitChunks.name = true;
    }

    Object.assign(config, {
      output,
      optimization
    });
  }

  return config;
}

async function invokeWebpackConfigAsync(env, argv) {
  // Check if the project has a webpack.config.js in the root.
  const projectWebpackConfig = _path().default.resolve(env.projectRoot, 'webpack.config.js');

  let config;

  if (_fsExtra().default.existsSync(projectWebpackConfig)) {
    const webpackConfig = require(projectWebpackConfig);

    if (typeof webpackConfig === 'function') {
      config = await webpackConfig(env, argv);
    } else {
      config = webpackConfig;
    }
  } else {
    // Fallback to the default expo webpack config.
    const createExpoWebpackConfigAsync = require('@expo/webpack-config');

    config = await createExpoWebpackConfigAsync(env, argv);
  }

  return applyEnvironmentVariables(config);
}

async function openProjectAsync(projectRoot) {
  await Doctor().validateWebSupportAsync(projectRoot);

  try {
    let url = await UrlUtils().constructWebAppUrlAsync(projectRoot);

    if (!url) {
      throw new Error('Webpack Dev Server is not running');
    }

    (0, _openBrowser().default)(url);
    return {
      success: true,
      url
    };
  } catch (e) {
    _Logger().default.global.error(`Couldn't start project on web: ${e.message}`);

    return {
      success: false,
      error: e
    };
  }
} // If platforms only contains the "web" field


async function onlySupportsWebAsync(projectRoot) {
  const {
    exp
  } = await (0, _config().readConfigJsonAsync)(projectRoot);

  if (Array.isArray(exp.platforms) && exp.platforms.length === 1) {
    return exp.platforms[0] === 'web';
  }

  return false;
}
//# sourceMappingURL=__sourcemaps__/Web.js.map
