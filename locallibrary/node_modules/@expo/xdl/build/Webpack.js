"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startAsync = startAsync;
exports.stopAsync = stopAsync;
exports.openAsync = openAsync;
exports.bundleAsync = bundleAsync;
exports.getProjectNameAsync = getProjectNameAsync;
exports.getProjectUseNextJsAsync = getProjectUseNextJsAsync;
exports.getServer = getServer;
exports.getPort = getPort;
exports.getUrlAsync = getUrlAsync;
exports.getProtocolAsync = getProtocolAsync;
exports.getAvailablePortAsync = getAvailablePortAsync;
exports.setMode = setMode;
exports.DEFAULT_PORT = exports.HOST = void 0;

function ConfigUtils() {
  const data = _interopRequireWildcard(require("@expo/config"));

  ConfigUtils = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _formatWebpackMessages() {
  const data = _interopRequireDefault(require("react-dev-utils/formatWebpackMessages"));

  _formatWebpackMessages = function () {
    return data;
  };

  return data;
}

function _WebpackDevServerUtils() {
  const data = require("react-dev-utils/WebpackDevServerUtils");

  _WebpackDevServerUtils = function () {
    return data;
  };

  return data;
}

function _webpack() {
  const data = _interopRequireDefault(require("webpack"));

  _webpack = function () {
    return data;
  };

  return data;
}

function _webpackDevServer() {
  const data = _interopRequireDefault(require("webpack-dev-server"));

  _webpackDevServer = function () {
    return data;
  };

  return data;
}

function _express() {
  const data = _interopRequireDefault(require("express"));

  _express = function () {
    return data;
  };

  return data;
}

function _getenv() {
  const data = _interopRequireDefault(require("getenv"));

  _getenv = function () {
    return data;
  };

  return data;
}

function _createWebpackCompiler() {
  const data = _interopRequireWildcard(require("./createWebpackCompiler"));

  _createWebpackCompiler = function () {
    return data;
  };

  return data;
}

function _ip() {
  const data = _interopRequireDefault(require("./ip"));

  _ip = function () {
    return data;
  };

  return data;
}

function ProjectUtils() {
  const data = _interopRequireWildcard(require("./project/ProjectUtils"));

  ProjectUtils = function () {
    return data;
  };

  return data;
}

function ProjectSettings() {
  const data = _interopRequireWildcard(require("./ProjectSettings"));

  ProjectSettings = function () {
    return data;
  };

  return data;
}

function Web() {
  const data = _interopRequireWildcard(require("./Web"));

  Web = function () {
    return data;
  };

  return data;
}

function Doctor() {
  const data = _interopRequireWildcard(require("./project/Doctor"));

  Doctor = function () {
    return data;
  };

  return data;
}

function _XDLError() {
  const data = _interopRequireDefault(require("./XDLError"));

  _XDLError = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

// @ts-ignore missing types for Doctor until it gets converted to TypeScript
const HOST = _getenv().default.string('WEB_HOST', '0.0.0.0');

exports.HOST = HOST;

const DEFAULT_PORT = _getenv().default.int('WEB_PORT', 19006);

exports.DEFAULT_PORT = DEFAULT_PORT;
const WEBPACK_LOG_TAG = 'expo';
let webpackDevServerInstance = null;
let webpackServerPort = null;

async function startAsync(projectRoot, options = {}, deprecatedVerbose) {
  if (typeof deprecatedVerbose !== 'undefined') {
    throw new (_XDLError().default)('WEBPACK_DEPRECATED', 'startAsync(root, options, verbose): The `verbose` option is deprecated.');
  }

  const usingNextJs = await getProjectUseNextJsAsync(projectRoot);
  options.unimodulesOnly = usingNextJs;
  let serverName = 'Webpack';

  if (usingNextJs) {
    serverName = 'Next.js';
  }

  if (webpackDevServerInstance) {
    ProjectUtils().logError(projectRoot, WEBPACK_LOG_TAG, `${serverName} is already running.`);
    return null;
  }

  const {
    env,
    config
  } = await createWebpackConfigAsync(projectRoot, options);
  const port = await getAvailablePortAsync({
    defaultPort: options.port
  });
  webpackServerPort = port;
  ProjectUtils().logInfo(projectRoot, WEBPACK_LOG_TAG, `Starting ${serverName} on port ${webpackServerPort} in ${_chalk().default.underline(env.mode)} mode.`);
  const protocol = env.https ? 'https' : 'http';
  const urls = (0, _WebpackDevServerUtils().prepareUrls)(protocol, '::', webpackServerPort);
  const useYarn = ConfigUtils().isUsingYarn(projectRoot);
  const appName = await getProjectNameAsync(projectRoot);
  const nonInteractive = validateBoolOption('nonInteractive', options.nonInteractive, !!process.stdout.isTTY);
  let server;

  if (usingNextJs) {
    if (protocol === 'https') {
      // TODO: Support https.
      throw new Error('https with Next.js is not supported for now.');
    }

    server = await startNextJsAsync({
      projectRoot,
      port: webpackServerPort,
      dev: env.development,
      expoWebpackConfig: config
    });
    (0, _createWebpackCompiler().printSuccessMessages)({
      projectRoot,
      appName,
      urls,
      config,
      isFirstCompile: true,
      nonInteractive
    });
  } else {
    server = await new Promise(resolve => {
      // Create a webpack compiler that is configured with custom messages.
      const compiler = (0, _createWebpackCompiler().default)({
        projectRoot,
        nonInteractive,
        webpackFactory: _webpack().default,
        appName,
        config,
        urls,
        useYarn,
        onFinished: () => resolve(server)
      });
      const server = new (_webpackDevServer().default)(compiler, config.devServer); // Launch WebpackDevServer.

      server.listen(port, HOST, error => {
        if (error) {
          ProjectUtils().logError(projectRoot, WEBPACK_LOG_TAG, error.message);
        }

        if (typeof options.onWebpackFinished === 'function') {
          options.onWebpackFinished(error);
        }
      });
      webpackDevServerInstance = server;
    });
  }

  await ProjectSettings().setPackagerInfoAsync(projectRoot, {
    webpackServerPort
  });

  const host = _ip().default.address();

  const url = `${protocol}://${host}:${webpackServerPort}`;
  return {
    url,
    server,
    port,
    protocol,
    host
  };
}

async function stopAsync(projectRoot) {
  if (webpackDevServerInstance) {
    const server = webpackDevServerInstance;
    await new Promise(resolve => server.close(() => resolve()));
    webpackDevServerInstance = null;
    webpackServerPort = null;
    await ProjectSettings().setPackagerInfoAsync(projectRoot, {
      webpackServerPort: null
    });
  }
}

async function openAsync(projectRoot, options) {
  if (!webpackDevServerInstance) {
    await startAsync(projectRoot, options);
  }

  await Web().openProjectAsync(projectRoot);
}

async function bundleAsync(projectRoot, options) {
  const usingNextJs = await getProjectUseNextJsAsync(projectRoot);
  const {
    config
  } = await createWebpackConfigAsync(projectRoot, { ...options,
    unimodulesOnly: usingNextJs
  });

  if (usingNextJs) {
    await bundleNextJsAsync({
      projectRoot,
      expoWebpackConfig: config
    });
  } else {
    const compiler = (0, _webpack().default)(config);

    try {
      // We generate the stats.json file in the webpack-config
      const {
        stats,
        warnings
      } = await new Promise((resolve, reject) => compiler.run((error, stats) => {
        let messages;

        if (error) {
          if (!error.message) {
            return reject(error);
          }

          messages = (0, _formatWebpackMessages().default)({
            errors: [error.message],
            warnings: [],
            _showErrors: true,
            _showWarnings: true
          });
        } else {
          messages = (0, _formatWebpackMessages().default)(stats.toJson({
            all: false,
            warnings: true,
            errors: true
          }));
        }

        if (messages.errors.length) {
          // Only keep the first error. Others are often indicative
          // of the same problem, but confuse the reader with noise.
          if (messages.errors.length > 1) {
            messages.errors.length = 1;
          }

          return reject(new Error(messages.errors.join('\n\n')));
        }

        if (process.env.CI && (typeof process.env.CI !== 'string' || process.env.CI.toLowerCase() !== 'false') && messages.warnings.length) {
          console.log(_chalk().default.yellow('\nTreating warnings as errors because process.env.CI = true.\n' + 'Most CI servers set it automatically.\n'));
          return reject(new Error(messages.warnings.join('\n\n')));
        }

        resolve({
          stats,
          warnings: messages.warnings
        });
      }));

      if (warnings.length) {
        console.log(_chalk().default.yellow('Compiled with warnings.\n'));
        console.log(warnings.join('\n\n'));
      } else {
        console.log(_chalk().default.green('Compiled successfully.\n'));
      }
    } catch (error) {
      console.log(_chalk().default.red('Failed to compile.\n'));
      throw error;
    }
  }
}

async function getProjectNameAsync(projectRoot) {
  const {
    exp
  } = await ConfigUtils().readConfigJsonAsync(projectRoot);
  const {
    webName
  } = ConfigUtils().getNameFromConfig(exp);
  return webName;
}

async function getProjectUseNextJsAsync(projectRoot) {
  const {
    exp
  } = await ConfigUtils().readConfigJsonAsync(projectRoot);
  const {
    use = null
  } = exp.web || {};
  return use === 'nextjs';
}

function getServer(projectRoot) {
  if (webpackDevServerInstance == null) {
    ProjectUtils().logError(projectRoot, WEBPACK_LOG_TAG, 'Webpack is not running.');
  }

  return webpackDevServerInstance;
}

function getPort() {
  return webpackServerPort;
}

async function getUrlAsync(projectRoot) {
  const devServer = getServer(projectRoot);

  if (!devServer) {
    return null;
  }

  const host = _ip().default.address();

  const protocol = await getProtocolAsync(projectRoot);
  return `${protocol}://${host}:${webpackServerPort}`;
}

async function getProtocolAsync(projectRoot) {
  // TODO: Bacon: Handle when not in expo
  const {
    https
  } = await ProjectSettings().readAsync(projectRoot);
  return https === true ? 'https' : 'http';
}

async function getAvailablePortAsync(options = {}) {
  try {
    const defaultPort = 'defaultPort' in options && options.defaultPort ? options.defaultPort : DEFAULT_PORT;
    const port = await (0, _WebpackDevServerUtils().choosePort)('host' in options && options.host ? options.host : HOST, defaultPort);
    if (!port) throw new Error(`Port ${defaultPort} not available.`);else return port;
  } catch (error) {
    throw new (_XDLError().default)('NO_PORT_FOUND', 'No available port found: ' + error.message);
  }
}

function setMode(mode) {
  process.env.BABEL_ENV = mode;
  process.env.NODE_ENV = mode;
}

function validateBoolOption(name, value, defaultValue) {
  if (typeof value === 'undefined') {
    value = defaultValue;
  }

  if (typeof value !== 'boolean') {
    throw new (_XDLError().default)('WEBPACK_INVALID_OPTION', `'${name}' option must be a boolean.`);
  }

  return value;
}

function transformCLIOptions(options) {
  // Transform the CLI flags into more explicit values
  return { ...options,
    isImageEditingEnabled: options.pwa,
    isPolyfillEnabled: options.polyfill
  };
}

async function createWebpackConfigAsync(projectRoot, options = {}) {
  const fullOptions = transformCLIOptions(options);

  if (validateBoolOption('isValidationEnabled', fullOptions.isValidationEnabled, true)) {
    await Doctor().validateWebSupportAsync(projectRoot);
  }

  const env = await getWebpackConfigEnvFromBundlingOptionsAsync(projectRoot, fullOptions);
  setMode(env.mode);
  let config;

  if (options.unimodulesOnly) {
    const withUnimodules = require('@expo/webpack-config/withUnimodules');

    config = await withUnimodules({}, env);
  } else {
    config = await Web().invokeWebpackConfigAsync(env);
  }

  return {
    env,
    config
  };
}

async function applyOptionsToProjectSettingsAsync(projectRoot, options) {
  let newSettings = {}; // Change settings before reading them

  if (typeof options.https === 'boolean') {
    newSettings.https = options.https;
  }

  if (typeof options.dev === 'boolean') {
    newSettings.dev = options.dev;
  }

  if (Object.keys(newSettings).length) {
    await ProjectSettings().setAsync(projectRoot, newSettings);
  }

  return await ProjectSettings().readAsync(projectRoot);
}

async function getWebpackConfigEnvFromBundlingOptionsAsync(projectRoot, options) {
  let {
    dev,
    https
  } = await applyOptionsToProjectSettingsAsync(projectRoot, options);
  const mode = typeof options.mode === 'string' ? options.mode : dev ? 'development' : 'production';
  const isImageEditingEnabled = validateBoolOption('isImageEditingEnabled', options.isImageEditingEnabled, true);
  const isDebugInfoEnabled = validateBoolOption('isDebugInfoEnabled', options.isDebugInfoEnabled, Web().isInfoEnabled());
  return {
    projectRoot,
    pwa: isImageEditingEnabled,
    mode,
    https,
    polyfill: validateBoolOption('isPolyfillEnabled', options.isPolyfillEnabled, false),
    development: dev,
    production: !dev,
    info: isDebugInfoEnabled,
    ...(options.webpackEnv || {})
  };
}

async function startNextJsAsync({
  projectRoot,
  port,
  dev,
  expoWebpackConfig
}) {
  let next;

  try {
    const {
      exp
    } = await ConfigUtils().readConfigJsonAsync(projectRoot);
    next = require(ConfigUtils().resolveModule('next', projectRoot, exp));
  } catch (_unused) {
    throw new (_XDLError().default)('NEXTJS_NOT_INSTALLED', 'Next.js is not installed in your app. See https://docs.expo.io/versions/latest/guides/using-nextjs/');
  } // Build first if in production mode.
  // https://nextjs.org/docs#custom-server-and-routing


  if (!dev) {
    await bundleNextJsAsync({
      projectRoot,
      expoWebpackConfig
    });
  }

  await _copyCustomNextJsTemplatesAsync(projectRoot);
  const app = next({
    dev,
    dir: projectRoot,
    conf: _createNextJsConfig({
      projectRoot,
      expoWebpackConfig
    })
  });
  const handle = app.getRequestHandler();
  await app.prepare();
  const server = (0, _express().default)();
  server.get('*', handle);
  webpackDevServerInstance = server.listen(port, err => {
    if (err) {
      throw new Error(`Express server failed to start: ${err.toString()}`);
    }
  });
  return webpackDevServerInstance;
}

async function bundleNextJsAsync({
  projectRoot,
  expoWebpackConfig
}) {
  let nextBuild;

  try {
    const {
      exp
    } = await ConfigUtils().readConfigJsonAsync(projectRoot);
    nextBuild = require(ConfigUtils().resolveModule('next/dist/build', projectRoot, exp)).default;
  } catch (_unused2) {
    throw new (_XDLError().default)('NEXTJS_NOT_INSTALLED', 'Next.js (or its build component) is not installed in your app. See https://docs.expo.io/versions/latest/guides/using-nextjs/');
  }

  await _copyCustomNextJsTemplatesAsync(projectRoot);
  await nextBuild(projectRoot, _createNextJsConfig({
    projectRoot,
    expoWebpackConfig
  }));
}

function _createNextJsConfig({
  projectRoot,
  expoWebpackConfig
}) {
  let userNextJsConfig = {};

  const userNextConfigJsPath = _path().default.join(projectRoot, 'next.config.js');

  if (_fsExtra().default.existsSync(userNextConfigJsPath)) {
    userNextJsConfig = require(userNextConfigJsPath);
  } // `include` function is from https://github.com/expo/expo-cli/blob/3933f3d6ba65bffec2738ece71b62f2c284bd6e4/packages/webpack-config/webpack/loaders/createBabelLoaderAsync.js#L76-L96


  const expoBabelLoader = _findBabelLoader(expoWebpackConfig.module.rules);

  if (!expoBabelLoader) {
    throw new Error('Cannot find `babel-loader` generated by `@expo/webpack-config/withUnimodules`. It is likely an Expo issue. Please create a new issue at https://github.com/expo/expo-cli.');
  }

  const includeFunc = expoBabelLoader.include;
  return {
    // https://github.com/zeit/next.js#configuring-extensions-looked-for-when-resolving-pages-in-pages
    // Remove the `.` before each file extension
    pageExtensions: expoWebpackConfig.resolve.extensions.map(string => string.substr(1)),
    ...userNextJsConfig,
    // Note `webpack` has to come after `...userNextJsConfig` because we want to override that
    // User's `webpack` config is loaded below in `return`.
    webpack: (nextjsWebpackConfig, options) => {
      let newConfig = { ...nextjsWebpackConfig,
        module: { ...nextjsWebpackConfig.module,
          rules: [...nextjsWebpackConfig.module.rules, ...expoWebpackConfig.module.rules]
        },
        resolve: { ...nextjsWebpackConfig.resolve,
          symlinks: false,
          extensions: expoWebpackConfig.resolve.extensions,
          alias: { ...nextjsWebpackConfig.resolve.alias,
            ...expoWebpackConfig.resolve.alias
          }
        },
        resolveLoader: { ...expoWebpackConfig.resolveLoader,
          ...nextjsWebpackConfig.resolveLoader
        },
        plugins: [...nextjsWebpackConfig.plugins, ...expoWebpackConfig.plugins]
      }; // We have to transpile these modules and make them not external too.
      // We have to do this because next.js by default externals all `node_modules`'s js files.
      // Reference:
      // https://github.com/martpie/next-transpile-modules/blob/77450a0c0307e4b650d7acfbc18641ef9465f0da/index.js#L48-L62
      // https://github.com/zeit/next.js/blob/0b496a45e85f3c9aa3cf2e77eef10888be5884fc/packages/next/build/webpack-config.ts#L185-L258

      if (newConfig.externals) {
        newConfig.externals = newConfig.externals.map(external => {
          if (typeof external !== 'function') return external;
          return (ctx, req, cb) => {
            return includeFunc(_path().default.join('node_modules', req)) ? cb() : external(ctx, req, cb);
          };
        });
      } // If the user has webpack config in their next.config.js, we provide our config to them.
      // Reference: https://github.com/zeit/next-plugins/blob/8f9672dc0e189ffef5c99e588d40fa08d1d99d4f/packages/next-sass/index.js#L46-L50


      if (typeof userNextJsConfig.webpack === 'function') {
        return userNextJsConfig.webpack(newConfig, options);
      }

      return newConfig;
    }
  };
}

function _findBabelLoader(rules) {
  for (const rule of rules) {
    if (rule.use && rule.use.loader && rule.use.loader.includes('/babel-loader')) {
      return rule;
    }
  }

  return null;
}

async function _copyCustomNextJsTemplatesAsync(projectRoot) {
  try {
    await _fsExtra().default.writeFile(_path().default.join(projectRoot, '.expo', 'next_document.js'), nextJsDocument);
  } catch (e) {
    throw new Error(`Could not write to _document.js: ${e.toString()}`);
  }

  const pagesDocument = _path().default.join(projectRoot, 'pages', '_document.js');

  if (!_fsExtra().default.existsSync(pagesDocument)) {
    // Only write to `pages/_document.js` if it doesn't exists.
    try {
      await _fsExtra().default.writeFile(pagesDocument, nextJsImportDocument);
    } catch (e) {
      throw new Error(`Could not write to pages/_document.js: ${e.toString()}`);
    }
  }
}

const nextJsDocument = `\
// Based on https://github.com/zeit/next.js/tree/canary/examples/with-react-native-web
// and https://github.com/expo/expo-cli/blob/master/packages/webpack-config/web-default/index.html
import Document, { Head, Main, NextScript } from 'next/document'
import React from 'react'
import { AppRegistry } from 'react-native'

const normalizeNextElements = \`
/**
 * Building on the RNWeb reset:
 * https://github.com/necolas/react-native-web/blob/master/packages/react-native-web/src/exports/StyleSheet/initialRules.js
 */
html, body, #__next {
  width: 100%;
  /* To smooth any scrolling behavior */
  -webkit-overflow-scrolling: touch;
  margin: 0px;
  padding: 0px;
  /* Allows content to fill the viewport and go beyond the bottom */
  min-height: 100%;
}
#__next {
  flex-shrink: 0;
  flex-basis: auto;
  flex-grow: 1;
  display: flex;
  flex: 1;
}
html {
  font-size: 14px;
  scroll-behavior: smooth;
  /* Prevent text size change on orientation change https://gist.github.com/tfausak/2222823#file-ios-8-web-app-html-L138 */
  -webkit-text-size-adjust: 100%;
  height: 100%;
}
body {
  display: flex;
  /* Allows you to scroll below the viewport; default value is visible */
  overflow-y: auto;
  overscroll-behavior-y: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -ms-overflow-style: scrollbar;
}
\`;

export default class ExpoDocument extends Document {
  static async getInitialProps ({ renderPage }) {
    AppRegistry.registerComponent('Main', () => Main)
    const { getStyleElement } = AppRegistry.getApplication('Main')
    const page = renderPage()
    const styles = [
      <style dangerouslySetInnerHTML={{ __html: normalizeNextElements }} />,
      getStyleElement()
    ]
    return { ...page, styles: React.Children.toArray(styles) }
  }

  render () {
    return (
      <html>
        <Head>
          <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </html>
    );
  }
}
`;
const nextJsImportDocument = `\
import ExpoDocument from '../.expo/next_document';
export default ExpoDocument;
`;
//# sourceMappingURL=__sourcemaps__/Webpack.js.map
